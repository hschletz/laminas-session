{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"config/","text":"Session Config laminas-session comes with a standard set of config classes, allowing setting where a cookie lives, session lifetime, and even configuration of ext/session when using Laminas\\Session\\Config\\SessionConfig . Standard Config Laminas\\Session\\Config\\StandardConfig provides the base interface for configuring sessions when not leveraging ext/session. This is utilized more for specialized cases, such as when you might have session management done by another system, or when testing. Basic Configuration Options The following configuration options are defined by Laminas\\Session\\Config\\StandardConfig . Option Data Type Description cache_expire integer Specifies time-to-live for cached session pages in minutes. cookie_domain string Specifies the domain to set in the session cookie. cookie_httponly boolean Marks the cookie as accessible only through the HTTP protocol. cookie_lifetime integer Specifies the lifetime of the cookie in seconds which is sent to the browser. cookie_path string Specifies path to set in the session cookie. cookie_samesite string Specifies whether cookies should be sent along with cross-site requests. (Since 2.11.0) cookie_secure boolean Specifies whether cookies should only be sent over secure connections. entropy_length integer Specifies the number of bytes which will be read from the file specified in entropy_file. Removed in PHP 7.1.0. entropy_file string Defines a path to an external resource (file) which will be used as an additional entropy. Removed in PHP 7.1.0. gc_maxlifetime integer Specifies the number of seconds after which data will be seen as ‘garbage’. gc_divisor integer Defines the probability that the gc process is started on every session initialization. gc_probability integer Defines the probability that the gc process is started on every session initialization. hash_function integer Defines which built-in hash algorithm is used. Removed in PHP 7.1.0. hash_bits_per_character integer Defines how many bits are stored in each character when converting the binary hash data. Removed in PHP 7.1.0. name string Specifies the name of the session which is used as cookie name. remember_me_seconds integer Specifies how long to remember the session before clearing data. save_path string Defines the argument which is passed to the save handler. use_cookies boolean Specifies whether the module will use cookies to store the session id. Basic Usage use Laminas\\Session\\Config\\StandardConfig; use Laminas\\Session\\SessionManager; $config = new StandardConfig(); $config-&gt;setOptions([ 'remember_me_seconds' =&gt; 1800, 'name' =&gt; 'laminas', ]); $manager = new SessionManager($config); Session Config Laminas\\Session\\Config\\SessionConfig provides an interface for configuring sessions that leverage PHP's ext/session. Most configuration options configure either the Laminas\\Session\\Storage OR configure ext/session directly. Basic Configuration Options The following configuration options are defined by Laminas\\Session\\Config\\SessionConfig ; note that it inherits all configuration from Laminas\\Session\\Config\\StandardConfig . Option Data Type Description cache_limiter string Specifies the cache control method used for session pages. hash_function string Allows you to specify the hash algorithm used to generate the session IDs. php_save_handler string Defines the name of a PHP save_handler embedded into PHP. serialize_handler string Defines the name of the handler which is used to serialize/deserialize data. url_rewriter_tags string Specifies which HTML tags are rewritten to include session id if transparent sid enabled. use_trans_sid boolean Whether transparent sid support is enabled or not. Basic Usage use Laminas\\Session\\Config\\SessionConfig; use Laminas\\Session\\SessionManager; $config = new SessionConfig(); $config-&gt;setOptions([ 'phpSaveHandler' =&gt; 'redis', 'savePath' =&gt; 'tcp://127.0.0.1:6379?weight=1&amp;timeout=1', ]); $manager = new SessionManager($config); Service Manager Factory laminas-session ships with a laminas-servicemanager factory which reads configuration data from the application configuration and injects a corresponding instance of Laminas\\Session\\Config\\SessionConfig into the session manager automatically. To use this factory, you first need to register it with the service manager by adding the appropriate factory definition: 'service_manager' =&gt; [ 'factories' =&gt; [ 'Laminas\\Session\\Config\\ConfigInterface' =&gt; 'Laminas\\Session\\Service\\SessionConfigFactory', ], ], Automated factory registration Starting with laminas-mvc v3, if you are using the component installer in your application, the above registration will be made automatically for you when you install laminas-session. Then place your application's session configuration in the root-level configuration key session_config : 'session_config' =&gt; [ 'phpSaveHandler' =&gt; 'redis', 'savePath' =&gt; 'tcp://127.0.0.1:6379?weight=1&amp;timeout=1', ], Any of the configuration options defined for SessionConfig can be used there, as well as the following factory-specific configuration options: Option Data Type Description config_class string Name of the class to use as the configuration container (Defaults to Laminas\\Session\\Config\\SessionConfig ) Custom Configuration In the event that you prefer to create your own session configuration; you must implement Laminas\\Session\\Config\\ConfigInterface which contains the basic interface for items needed when implementing a session. This includes cookie configuration, lifetime, session name, save path, and an interface for getting and setting options.","title":"Session Config"},{"location":"config/#session-config","text":"laminas-session comes with a standard set of config classes, allowing setting where a cookie lives, session lifetime, and even configuration of ext/session when using Laminas\\Session\\Config\\SessionConfig .","title":"Session Config"},{"location":"config/#standard-config","text":"Laminas\\Session\\Config\\StandardConfig provides the base interface for configuring sessions when not leveraging ext/session. This is utilized more for specialized cases, such as when you might have session management done by another system, or when testing.","title":"Standard Config"},{"location":"config/#session-config_1","text":"Laminas\\Session\\Config\\SessionConfig provides an interface for configuring sessions that leverage PHP's ext/session. Most configuration options configure either the Laminas\\Session\\Storage OR configure ext/session directly.","title":"Session Config"},{"location":"config/#custom-configuration","text":"In the event that you prefer to create your own session configuration; you must implement Laminas\\Session\\Config\\ConfigInterface which contains the basic interface for items needed when implementing a session. This includes cookie configuration, lifetime, session name, save path, and an interface for getting and setting options.","title":"Custom Configuration"},{"location":"container/","text":"Session Container Laminas\\Session\\Container instances provide the primary API for manipulating session data in laminas-session. Containers are used to segregate all session data, although a default namespace exists for those who only want one namespace for all their session data. Each instance of Laminas\\Session\\Container corresponds to an entry of the Laminas\\Session\\Storage , where the namespace is used as the key. Laminas\\Session\\Container itself is an instance of an ArrayObject . Basic Usage use Laminas\\Session\\Container; $container = new Container('namespace'); $container-&gt;item = 'foo'; Setting the Default Session Manager In the event you are using multiple session managers or prefer to be explicit, the default session manager that is utilized can be explicitly set. use Laminas\\Session\\Container; use Laminas\\Session\\SessionManager; $manager = new SessionManager(); Container::setDefaultManager($manager);","title":"Session Container"},{"location":"container/#session-container","text":"Laminas\\Session\\Container instances provide the primary API for manipulating session data in laminas-session. Containers are used to segregate all session data, although a default namespace exists for those who only want one namespace for all their session data. Each instance of Laminas\\Session\\Container corresponds to an entry of the Laminas\\Session\\Storage , where the namespace is used as the key. Laminas\\Session\\Container itself is an instance of an ArrayObject .","title":"Session Container"},{"location":"container/#basic-usage","text":"use Laminas\\Session\\Container; $container = new Container('namespace'); $container-&gt;item = 'foo';","title":"Basic Usage"},{"location":"container/#setting-the-default-session-manager","text":"In the event you are using multiple session managers or prefer to be explicit, the default session manager that is utilized can be explicitly set. use Laminas\\Session\\Container; use Laminas\\Session\\SessionManager; $manager = new SessionManager(); Container::setDefaultManager($manager);","title":"Setting the Default Session Manager"},{"location":"installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"manager/","text":"Session Manager The session manager, Laminas\\Session\\SessionManager , is the class responsible for all aspects of session management. It initializes configuration, storage, and save handlers. Additionally the session manager can be injected into the session container to provide a wrapper or namespace around your session data. The session manager is responsible for starting a session, testing if a session exists, writing to the session, regenerating the session identifier, setting the session time-to-live, and destroying the session. The session manager can validate sessions from a validator chain to ensure that the session data is correct. Initializing the Session Manager Generally speaking, you will always want to initialize the session manager and ensure that your application was responsible for its initialization; this puts in place a simple solution to prevent against session fixation. Generally you will setup configuration and then inside of an application module bootstrap the session manager. Additionally you will likely want to supply validators to prevent against session hijacking. The following illustrates how you may configure the session manager by setting options in your local or global config: use Laminas\\Session; return [ 'session_manager' =&gt; [ 'config' =&gt; [ 'class' =&gt; Session\\Config\\SessionConfig::class, 'options' =&gt; [ 'name' =&gt; 'myapp', ], ], 'storage' =&gt; Session\\Storage\\SessionArrayStorage::class, 'validators' =&gt; [ Session\\Validator\\RemoteAddr::class, Session\\Validator\\HttpUserAgent::class, ], ], ]; The following illustrates how you might utilize the above configuration to create the session manager: use Laminas\\Mvc\\ModuleRouteListener; use Laminas\\Mvc\\MvcEvent; use Laminas\\Session\\SessionManager; use Laminas\\Session\\Config\\SessionConfig; use Laminas\\Session\\Container; use Laminas\\Session\\Validator; class Module { public function onBootstrap(MvcEvent $e) { $eventManager = $e-&gt;getApplication()-&gt;getEventManager(); $moduleRouteListener = new ModuleRouteListener(); $moduleRouteListener-&gt;attach($eventManager); $this-&gt;bootstrapSession($e); } public function bootstrapSession(MvcEvent $e) { $session = $e-&gt;getApplication() -&gt;getServiceManager() -&gt;get(SessionManager::class); $session-&gt;start(); $container = new Container('initialized'); if (isset($container-&gt;init)) { return; } $serviceManager = $e-&gt;getApplication()-&gt;getServiceManager(); $request = $serviceManager-&gt;get('Request'); $session-&gt;regenerateId(true); $container-&gt;init = 1; $container-&gt;remoteAddr = $request-&gt;getServer()-&gt;get('REMOTE_ADDR'); $container-&gt;httpUserAgent = $request-&gt;getServer()-&gt;get('HTTP_USER_AGENT'); $config = $serviceManager-&gt;get('Config'); if (! isset($config['session'])) { return; } $sessionConfig = $config['session']; if (! isset($sessionConfig['validators'])) { return; } $chain = $session-&gt;getValidatorChain(); foreach ($sessionConfig['validators'] as $validator) { switch ($validator) { case Validator\\HttpUserAgent::class: $validator = new $validator($container-&gt;httpUserAgent); break; case Validator\\RemoteAddr::class: $validator = new $validator($container-&gt;remoteAddr); break; default: $validator = new $validator(); break; } $chain-&gt;attach('session.validate', array($validator, 'isValid')); } } public function getServiceConfig() { return [ 'factories' =&gt; [ SessionManager::class =&gt; function ($container) { $config = $container-&gt;get('config'); if (! isset($config['session'])) { $sessionManager = new SessionManager(); Container::setDefaultManager($sessionManager); return $sessionManager; } $session = $config['session']; $sessionConfig = null; if (isset($session['config'])) { $class = isset($session['config']['class']) ? $session['config']['class'] : SessionConfig::class; $options = isset($session['config']['options']) ? $session['config']['options'] : []; $sessionConfig = new $class(); $sessionConfig-&gt;setOptions($options); } $sessionStorage = null; if (isset($session['storage'])) { $class = $session['storage']; $sessionStorage = new $class(); } $sessionSaveHandler = null; if (isset($session['save_handler'])) { // class should be fetched from service manager // since it will require constructor arguments $sessionSaveHandler = $container-&gt;get($session['save_handler']); } $sessionManager = new SessionManager( $sessionConfig, $sessionStorage, $sessionSaveHandler ); Container::setDefaultManager($sessionManager); return $sessionManager; }, ], ]; } } When you create a new Laminas\\Session\\Container (see Session Container page) in a controller, for example, it will use the session configured above.","title":"Session Manager"},{"location":"manager/#session-manager","text":"The session manager, Laminas\\Session\\SessionManager , is the class responsible for all aspects of session management. It initializes configuration, storage, and save handlers. Additionally the session manager can be injected into the session container to provide a wrapper or namespace around your session data. The session manager is responsible for starting a session, testing if a session exists, writing to the session, regenerating the session identifier, setting the session time-to-live, and destroying the session. The session manager can validate sessions from a validator chain to ensure that the session data is correct.","title":"Session Manager"},{"location":"manager/#initializing-the-session-manager","text":"Generally speaking, you will always want to initialize the session manager and ensure that your application was responsible for its initialization; this puts in place a simple solution to prevent against session fixation. Generally you will setup configuration and then inside of an application module bootstrap the session manager. Additionally you will likely want to supply validators to prevent against session hijacking. The following illustrates how you may configure the session manager by setting options in your local or global config: use Laminas\\Session; return [ 'session_manager' =&gt; [ 'config' =&gt; [ 'class' =&gt; Session\\Config\\SessionConfig::class, 'options' =&gt; [ 'name' =&gt; 'myapp', ], ], 'storage' =&gt; Session\\Storage\\SessionArrayStorage::class, 'validators' =&gt; [ Session\\Validator\\RemoteAddr::class, Session\\Validator\\HttpUserAgent::class, ], ], ]; The following illustrates how you might utilize the above configuration to create the session manager: use Laminas\\Mvc\\ModuleRouteListener; use Laminas\\Mvc\\MvcEvent; use Laminas\\Session\\SessionManager; use Laminas\\Session\\Config\\SessionConfig; use Laminas\\Session\\Container; use Laminas\\Session\\Validator; class Module { public function onBootstrap(MvcEvent $e) { $eventManager = $e-&gt;getApplication()-&gt;getEventManager(); $moduleRouteListener = new ModuleRouteListener(); $moduleRouteListener-&gt;attach($eventManager); $this-&gt;bootstrapSession($e); } public function bootstrapSession(MvcEvent $e) { $session = $e-&gt;getApplication() -&gt;getServiceManager() -&gt;get(SessionManager::class); $session-&gt;start(); $container = new Container('initialized'); if (isset($container-&gt;init)) { return; } $serviceManager = $e-&gt;getApplication()-&gt;getServiceManager(); $request = $serviceManager-&gt;get('Request'); $session-&gt;regenerateId(true); $container-&gt;init = 1; $container-&gt;remoteAddr = $request-&gt;getServer()-&gt;get('REMOTE_ADDR'); $container-&gt;httpUserAgent = $request-&gt;getServer()-&gt;get('HTTP_USER_AGENT'); $config = $serviceManager-&gt;get('Config'); if (! isset($config['session'])) { return; } $sessionConfig = $config['session']; if (! isset($sessionConfig['validators'])) { return; } $chain = $session-&gt;getValidatorChain(); foreach ($sessionConfig['validators'] as $validator) { switch ($validator) { case Validator\\HttpUserAgent::class: $validator = new $validator($container-&gt;httpUserAgent); break; case Validator\\RemoteAddr::class: $validator = new $validator($container-&gt;remoteAddr); break; default: $validator = new $validator(); break; } $chain-&gt;attach('session.validate', array($validator, 'isValid')); } } public function getServiceConfig() { return [ 'factories' =&gt; [ SessionManager::class =&gt; function ($container) { $config = $container-&gt;get('config'); if (! isset($config['session'])) { $sessionManager = new SessionManager(); Container::setDefaultManager($sessionManager); return $sessionManager; } $session = $config['session']; $sessionConfig = null; if (isset($session['config'])) { $class = isset($session['config']['class']) ? $session['config']['class'] : SessionConfig::class; $options = isset($session['config']['options']) ? $session['config']['options'] : []; $sessionConfig = new $class(); $sessionConfig-&gt;setOptions($options); } $sessionStorage = null; if (isset($session['storage'])) { $class = $session['storage']; $sessionStorage = new $class(); } $sessionSaveHandler = null; if (isset($session['save_handler'])) { // class should be fetched from service manager // since it will require constructor arguments $sessionSaveHandler = $container-&gt;get($session['save_handler']); } $sessionManager = new SessionManager( $sessionConfig, $sessionStorage, $sessionSaveHandler ); Container::setDefaultManager($sessionManager); return $sessionManager; }, ], ]; } } When you create a new Laminas\\Session\\Container (see Session Container page) in a controller, for example, it will use the session configured above.","title":"Initializing the Session Manager"},{"location":"save-handler/","text":"Session Save Handlers laminas-session comes with a set of save handler classes. Save handlers themselves are decoupled from PHP's save handler functions and are only implemented as a PHP save handler when utilized in conjunction with Laminas\\Session\\SessionManager . Cache Laminas\\Session\\SaveHandler\\Cache allows you to provide an instance of Laminas\\Cache\\Storage\\Adapter\\AdapterInterface to be utilized as a session save handler. Generally if you are utilizing the Cache save handler; you are likely using products such as memcached. Basic usage A basic example is one like the following: use Laminas\\Cache\\StorageFactory; use Laminas\\Session\\SaveHandler\\Cache; use Laminas\\Session\\SessionManager; $cache = StorageFactory::factory([ 'adapter' =&gt; [ 'name' =&gt; 'memcached', 'options' =&gt; [ 'server' =&gt; '127.0.0.1', ], ], ]); $saveHandler = new Cache($cache); $manager = new SessionManager(); $manager-&gt;setSaveHandler($saveHandler); DbTableGateway Laminas\\Session\\SaveHandler\\DbTableGateway allows you to utilize Laminas\\Db\\TableGateway\\TableGatewayInterface implementations as a session save handler. Setup of a DbTableGateway save handler requires an instance of Laminas\\Db\\TableGateway\\TableGatewayInterface and an instance of Laminas\\Session\\SaveHandler\\DbTableGatewayOptions . In the most basic setup, a TableGateway object and using the defaults of the DbTableGatewayOptions will provide you with what you need. Creating the database table CREATE TABLE `session` ( `id` char(32), `name` char(32), `modified` int, `lifetime` int, `data` text, PRIMARY KEY (`id`, `name`) ); Basic usage use Laminas\\Db\\TableGateway\\TableGateway; use Laminas\\Session\\SaveHandler\\DbTableGateway; use Laminas\\Session\\SaveHandler\\DbTableGatewayOptions; use Laminas\\Session\\SessionManager; $tableGateway = new TableGateway('session', $adapter); $saveHandler = new DbTableGateway($tableGateway, new DbTableGatewayOptions()); $manager = new SessionManager(); $manager-&gt;setSaveHandler($saveHandler); MongoDB Laminas\\Session\\SaveHandler\\MongoDB allows you to provide a MongoDB collection to be utilized as a session save handler. You provide the options in the Laminas\\Session\\SaveHandler\\MongoDBOptions class. You must install the mongodb PHP extensions and the MongoDB PHP library . Basic Usage use MongoDB\\Client; use Laminas\\Session\\SaveHandler\\MongoDB; use Laminas\\Session\\SaveHandler\\MongoDBOptions; use Laminas\\Session\\SessionManager; $mongoClient = new Client(); $options = new MongoDBOptions([ 'database' =&gt; 'myapp', 'collection' =&gt; 'sessions', ]); $saveHandler = new MongoDB($mongoClient, $options); $manager = new SessionManager(); $manager-&gt;setSaveHandler($saveHandler); Custom Save Handlers There may be cases where you want to create a save handler. Creating a custom save handler is much like creating a custom PHP save handler, with minor differences. All laminas-session-compatible save handlers must implement Laminas\\Session\\SaveHandler\\SaveHandlerInterface . Additionally, if your save handler has configurable functionality, you will also need to create an options class.","title":"Session Save Handlers"},{"location":"save-handler/#session-save-handlers","text":"laminas-session comes with a set of save handler classes. Save handlers themselves are decoupled from PHP's save handler functions and are only implemented as a PHP save handler when utilized in conjunction with Laminas\\Session\\SessionManager .","title":"Session Save Handlers"},{"location":"save-handler/#cache","text":"Laminas\\Session\\SaveHandler\\Cache allows you to provide an instance of Laminas\\Cache\\Storage\\Adapter\\AdapterInterface to be utilized as a session save handler. Generally if you are utilizing the Cache save handler; you are likely using products such as memcached.","title":"Cache"},{"location":"save-handler/#dbtablegateway","text":"Laminas\\Session\\SaveHandler\\DbTableGateway allows you to utilize Laminas\\Db\\TableGateway\\TableGatewayInterface implementations as a session save handler. Setup of a DbTableGateway save handler requires an instance of Laminas\\Db\\TableGateway\\TableGatewayInterface and an instance of Laminas\\Session\\SaveHandler\\DbTableGatewayOptions . In the most basic setup, a TableGateway object and using the defaults of the DbTableGatewayOptions will provide you with what you need.","title":"DbTableGateway"},{"location":"save-handler/#mongodb","text":"Laminas\\Session\\SaveHandler\\MongoDB allows you to provide a MongoDB collection to be utilized as a session save handler. You provide the options in the Laminas\\Session\\SaveHandler\\MongoDBOptions class. You must install the mongodb PHP extensions and the MongoDB PHP library .","title":"MongoDB"},{"location":"save-handler/#custom-save-handlers","text":"There may be cases where you want to create a save handler. Creating a custom save handler is much like creating a custom PHP save handler, with minor differences. All laminas-session-compatible save handlers must implement Laminas\\Session\\SaveHandler\\SaveHandlerInterface . Additionally, if your save handler has configurable functionality, you will also need to create an options class.","title":"Custom Save Handlers"},{"location":"storage/","text":"Session Storage laminas-session comes with a standard set of storage handlers. Storage handlers are the intermediary between when the session starts and when the session writes and closes. The default session storage is Laminas\\Session\\Storage\\SessionArrayStorage . Array Storage Laminas\\Session\\Storage\\ArrayStorage provides a facility to store all information in an ArrayObject . This storage method is likely incompatible with 3rd party libraries and all properties will be inaccessible through the $_SESSION superglobal. Additionally ArrayStorage will not automatically repopulate the storage container in the case of each new request and would have to manually be re-populated. Basic Usage use Laminas\\Session\\Storage\\ArrayStorage; use Laminas\\Session\\SessionManager; $populateStorage = ['foo' =&gt; 'bar']; $storage = new ArrayStorage($populateStorage); $manager = new SessionManager(); $manager-&gt;setStorage($storage); Session Storage Laminas\\Session\\Storage\\SessionStorage replaces $_SESSION, providing a facility to store all information in an ArrayObject . This means that it may not be compatible with 3rd party libraries, although information stored in the $_SESSION superglobal should be available in other scopes. Basic Usage use Laminas\\Session\\Storage\\SessionStorage; use Laminas\\Session\\SessionManager; $manager = new SessionManager(); $manager-&gt;setStorage(new SessionStorage()); Session Array Storage Laminas\\Session\\Storage\\SessionArrayStorage provides a facility to store all information directly in the $_SESSION superglobal. This storage class provides the most compatibility with 3rd party libraries and allows for directly storing information into $_SESSION . Basic Usage use Laminas\\Session\\Storage\\SessionArrayStorage; use Laminas\\Session\\SessionManager; $manager = new SessionManager(); $manager-&gt;setStorage(new SessionArrayStorage()); Custom Storage To create a custom storage container, you must implement Laminas\\Session\\Storage\\StorageInterface . This interface extends each of ArrayAccess , Traversable , Serializable , and Countable , and it is in the methods those define that the majority of implementation occurs. The following methods must also be implemented: public function getRequestAccessTime() : int; public function lock(int|string $key = null) : void; public function isLocked(int|string $key = null) : bool; public function unlock(int|string $key = null) : void; public function markImmutable() : void; public function isImmutable() : bool; public function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void; public function getMetadata(string $key = null) : mixed; public function clear(int|string $key = null) : void; public function fromArray(array $array) : void; public function toArray(bool $metaData = false) : array;","title":"Session Storage"},{"location":"storage/#session-storage","text":"laminas-session comes with a standard set of storage handlers. Storage handlers are the intermediary between when the session starts and when the session writes and closes. The default session storage is Laminas\\Session\\Storage\\SessionArrayStorage .","title":"Session Storage"},{"location":"storage/#array-storage","text":"Laminas\\Session\\Storage\\ArrayStorage provides a facility to store all information in an ArrayObject . This storage method is likely incompatible with 3rd party libraries and all properties will be inaccessible through the $_SESSION superglobal. Additionally ArrayStorage will not automatically repopulate the storage container in the case of each new request and would have to manually be re-populated.","title":"Array Storage"},{"location":"storage/#session-storage_1","text":"Laminas\\Session\\Storage\\SessionStorage replaces $_SESSION, providing a facility to store all information in an ArrayObject . This means that it may not be compatible with 3rd party libraries, although information stored in the $_SESSION superglobal should be available in other scopes.","title":"Session Storage"},{"location":"storage/#session-array-storage","text":"Laminas\\Session\\Storage\\SessionArrayStorage provides a facility to store all information directly in the $_SESSION superglobal. This storage class provides the most compatibility with 3rd party libraries and allows for directly storing information into $_SESSION .","title":"Session Array Storage"},{"location":"storage/#custom-storage","text":"To create a custom storage container, you must implement Laminas\\Session\\Storage\\StorageInterface . This interface extends each of ArrayAccess , Traversable , Serializable , and Countable , and it is in the methods those define that the majority of implementation occurs. The following methods must also be implemented: public function getRequestAccessTime() : int; public function lock(int|string $key = null) : void; public function isLocked(int|string $key = null) : bool; public function unlock(int|string $key = null) : void; public function markImmutable() : void; public function isImmutable() : bool; public function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void; public function getMetadata(string $key = null) : mixed; public function clear(int|string $key = null) : void; public function fromArray(array $array) : void; public function toArray(bool $metaData = false) : array;","title":"Custom Storage"},{"location":"application-integration/usage-in-a-laminas-mvc-application/","text":"Usage in a laminas-mvc Application The following example shows one potential use case of laminas-session within a laminas-mvc based application. The example uses a module, a controller and the session container . The example is based on the tutorial application , which builds an album inventory system. Before starting, make sure laminas-session is installed and configured. Set up Configuration To use a session container some configuration for the component is needed: a name for the container a storage handler some configuration for the session itself To allow a reflection-based approach to retrieve the session container from the service manager, a class name is needed as the name for the container. The example uses the name Laminas\\Session\\Container::class . Add the following lines to the local or global configuration file, e.g. config/autoload/global.config.php : return [ 'session_containers' =&gt; [ Laminas\\Session\\Container::class, ], 'session_storage' =&gt; [ 'type' =&gt; Laminas\\Session\\Storage\\SessionArrayStorage::class, ], 'session_config' =&gt; [ 'gc_maxlifetime' =&gt; 7200, // … ], // … ]; Session Configuration is Optional The configuration for the session itself is optional, but the factory Laminas\\Session\\Config\\SessionConfig , which is registered for configuration data, expects an array under the key session_config . A minimum configuration is: 'session_config' =&gt; [], Create and Register Controller Create a controller class and inject the session container with the registered classname, e.g. module/Album/Controller/AlbumController.php : namespace Album\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\Session\\Container as SessionContainer; class AlbumController extends AbstractActionController { /** @var SessionContainer */ private $sessionContainer; public function __construct(SessionContainer $sessionContainer) { $this-&gt;sessionContainer = $sessionContainer; } } To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; use Laminas\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; ReflectionBasedAbstractFactory::class, ], ], // … ]; The example uses the reflection factory from laminas-servicemanager to resolve the constructor dependencies for the controller class. Writing and Reading Session Data Using the session container in the controller, e.g. module/Album/Controller/AlbumController.php : Write Data public function indexAction() { $this-&gt;sessionContainer-&gt;album = 'I got a new CD with awesome music.'; return []; } Read Data public function addAction() { return [ 'album_message' =&gt; $this-&gt;sessionContainer-&gt;album ?? null, ]; }","title":"Usage in a laminas-mvc application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#usage-in-a-laminas-mvc-application","text":"The following example shows one potential use case of laminas-session within a laminas-mvc based application. The example uses a module, a controller and the session container . The example is based on the tutorial application , which builds an album inventory system. Before starting, make sure laminas-session is installed and configured.","title":"Usage in a laminas-mvc Application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#set-up-configuration","text":"To use a session container some configuration for the component is needed: a name for the container a storage handler some configuration for the session itself To allow a reflection-based approach to retrieve the session container from the service manager, a class name is needed as the name for the container. The example uses the name Laminas\\Session\\Container::class . Add the following lines to the local or global configuration file, e.g. config/autoload/global.config.php : return [ 'session_containers' =&gt; [ Laminas\\Session\\Container::class, ], 'session_storage' =&gt; [ 'type' =&gt; Laminas\\Session\\Storage\\SessionArrayStorage::class, ], 'session_config' =&gt; [ 'gc_maxlifetime' =&gt; 7200, // … ], // … ];","title":"Set up Configuration"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#create-and-register-controller","text":"Create a controller class and inject the session container with the registered classname, e.g. module/Album/Controller/AlbumController.php : namespace Album\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\Session\\Container as SessionContainer; class AlbumController extends AbstractActionController { /** @var SessionContainer */ private $sessionContainer; public function __construct(SessionContainer $sessionContainer) { $this-&gt;sessionContainer = $sessionContainer; } } To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; use Laminas\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; ReflectionBasedAbstractFactory::class, ], ], // … ]; The example uses the reflection factory from laminas-servicemanager to resolve the constructor dependencies for the controller class.","title":"Create and Register Controller"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#writing-and-reading-session-data","text":"Using the session container in the controller, e.g. module/Album/Controller/AlbumController.php :","title":"Writing and Reading Session Data"},{"location":"validators/csrf/","text":"CSRF Validator Laminas\\Session\\Validator\\Csrf provides the ability to both generate and validate CSRF tokens. This allows you to validate if a form submission originated from the same site, by confirming the value of the CSRF field in the submitted form is the same as the one contained in the original form. Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned. Supported Options The following options are supported for Laminas\\Session\\Validator\\Csrf . Option Description Optional/Mandatory name The name of the CSRF element Optional salt The salt for the CSRF token Optional session The session container instance that will store the CSRF tokens between requests Mandatory timeout The TTL for the CSRF token Optional Basic Usage Here is a basic example. // Initialise a new session container // or use the existing one in your application $session = new Laminas\\Session\\Container(); // Create the validator $validator = new Laminas\\Validator\\Csrf([ 'session' =&gt; $session, ]); $hash = $validator-&gt;getHash(); // ...Render the hash in the form. // Validate the hash after form submission. echo ($validator-&gt;isValid($hash)) ? \"Token is valid\" : \"Token is NOT valid\";","title":"CSRF Validator"},{"location":"validators/csrf/#csrf-validator","text":"Laminas\\Session\\Validator\\Csrf provides the ability to both generate and validate CSRF tokens. This allows you to validate if a form submission originated from the same site, by confirming the value of the CSRF field in the submitted form is the same as the one contained in the original form. Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned.","title":"CSRF Validator"},{"location":"validators/csrf/#supported-options","text":"The following options are supported for Laminas\\Session\\Validator\\Csrf . Option Description Optional/Mandatory name The name of the CSRF element Optional salt The salt for the CSRF token Optional session The session container instance that will store the CSRF tokens between requests Mandatory timeout The TTL for the CSRF token Optional","title":"Supported Options"},{"location":"validators/csrf/#basic-usage","text":"Here is a basic example. // Initialise a new session container // or use the existing one in your application $session = new Laminas\\Session\\Container(); // Create the validator $validator = new Laminas\\Validator\\Csrf([ 'session' =&gt; $session, ]); $hash = $validator-&gt;getHash(); // ...Render the hash in the form. // Validate the hash after form submission. echo ($validator-&gt;isValid($hash)) ? \"Token is valid\" : \"Token is NOT valid\";","title":"Basic Usage"},{"location":"validators/httpuseragent/","text":"Http User Agent Laminas\\Session\\Validator\\HttpUserAgent provides a validator to check the session against the originally stored $_SERVER['HTTP_USER_AGENT'] variable. Validation will fail in the event that this does not match and throws an exception in Laminas\\Session\\SessionManager after session_start() has been called. Basic Usage $manager = new Laminas\\Session\\SessionManager(); $manager-&gt;getValidatorChain()-&gt;attach( 'session.validate', [ new Laminas\\Session\\Validator\\HttpUserAgent(), 'isValid' ] );","title":"Http User Agent"},{"location":"validators/httpuseragent/#http-user-agent","text":"Laminas\\Session\\Validator\\HttpUserAgent provides a validator to check the session against the originally stored $_SERVER['HTTP_USER_AGENT'] variable. Validation will fail in the event that this does not match and throws an exception in Laminas\\Session\\SessionManager after session_start() has been called.","title":"Http User Agent"},{"location":"validators/httpuseragent/#basic-usage","text":"$manager = new Laminas\\Session\\SessionManager(); $manager-&gt;getValidatorChain()-&gt;attach( 'session.validate', [ new Laminas\\Session\\Validator\\HttpUserAgent(), 'isValid' ] );","title":"Basic Usage"},{"location":"validators/introduction/","text":"Introduction laminas-session provides a set of validators that provide protections against session hijacking and against unauthorized requests. Http User Agent Remote Addr Writing Custom Validators These validators are based on Laminas component for validation of data and files: laminas-validator . Installation Requirements The validation support of laminas-session depends on the laminas-validator component, so be sure to have it installed before getting started: $ composer require laminas/laminas-validator","title":"Introduction"},{"location":"validators/introduction/#introduction","text":"laminas-session provides a set of validators that provide protections against session hijacking and against unauthorized requests. Http User Agent Remote Addr Writing Custom Validators These validators are based on Laminas component for validation of data and files: laminas-validator . Installation Requirements The validation support of laminas-session depends on the laminas-validator component, so be sure to have it installed before getting started: $ composer require laminas/laminas-validator","title":"Introduction"},{"location":"validators/remoteaddr/","text":"Remote Addr Laminas\\Session\\Validator\\RemoteAddr provides a validator to check the session against the originally stored $_SERVER['REMOTE_ADDR'] variable. Validation will fail in the event that this does not match and throws an exception in Laminas\\Session\\SessionManager after session_start() has been called. Installation Requirements The validation of the IP address depends on the laminas-http component, so be sure to have it installed before getting started: $ composer require laminas/laminas-http Basic Usage $manager = new Laminas\\Session\\SessionManager(); $manager-&gt;getValidatorChain()-&gt;attach( 'session.validate', [ new Laminas\\Session\\Validator\\RemoteAddr(), 'isValid' ] );","title":"Remote Address"},{"location":"validators/remoteaddr/#remote-addr","text":"Laminas\\Session\\Validator\\RemoteAddr provides a validator to check the session against the originally stored $_SERVER['REMOTE_ADDR'] variable. Validation will fail in the event that this does not match and throws an exception in Laminas\\Session\\SessionManager after session_start() has been called. Installation Requirements The validation of the IP address depends on the laminas-http component, so be sure to have it installed before getting started: $ composer require laminas/laminas-http","title":"Remote Addr"},{"location":"validators/remoteaddr/#basic-usage","text":"$manager = new Laminas\\Session\\SessionManager(); $manager-&gt;getValidatorChain()-&gt;attach( 'session.validate', [ new Laminas\\Session\\Validator\\RemoteAddr(), 'isValid' ] );","title":"Basic Usage"},{"location":"validators/writing-custom-validators/","text":"Writing Custom Validators Own custom validators can be provided to validate against other items from storing a token and validating a token to other various techniques. To create a custom validator, the validation interface Laminas\\Session\\Validator\\ValidatorInterface must be implemented. More information on how to create custom validators can be found in the laminas-validator documentation .","title":"Writing Custom Validators"},{"location":"validators/writing-custom-validators/#writing-custom-validators","text":"Own custom validators can be provided to validate against other items from storing a token and validating a token to other various techniques. To create a custom validator, the validation interface Laminas\\Session\\Validator\\ValidatorInterface must be implemented. More information on how to create custom validators can be found in the laminas-validator documentation .","title":"Writing Custom Validators"}]}